/*
 * removeBackground.cpp
 *
 *  Created on: 07/07/2014
 *      Author: Diana Gil
 *      Following example from OpenCV tutorials
 */

// TODO: REMEMBER TO PUT LIBRARIES IN CORE.HPP BY QIFENG
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>

#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables...
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;
Mat dst;

// Function declarations
void extractForeground( Mat frame, double learningRate );
void Dilation( int dilation_elem, int dilation_size );
void Erosion( int erosion_elem, int erosion_size );
void applyMorphology( int morphoOperation, int morphoElement, int morphoSize );


int main(int argc, char* argv[])
{

	// Create GUI windows
	namedWindow("Frame");
	//namedWindow("FG Mask MOG");
	namedWindow("FG Mask MOG 2");
	namedWindow("Morphological operation result");

	// Parameters for background subtraction
	const double learningRate = 0.0;
	int bsHistory = 200;
	float bsThreshold = 16.0;
	bool bsShadow = false;

	// Create Background Subtractor objects
	pMOG = new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(bsHistory, bsThreshold, bsShadow); //MOG2 approach

	// Parameters for morphology operations
	int morphoOperation = 2;
	int morphoElement = 2;
	int morphoSize = 4;

	// -----------------------------------------------------------------
	// 						PROCESS VIDEO
	// -----------------------------------------------------------------
	// Create the capture object
	if (argc != 2)
	{
		cerr << "Video filename unknown" << endl;
		exit(EXIT_FAILURE);
	}
	const string videoFilename = argv[1];
	VideoCapture capture(videoFilename);
	if(!capture.isOpened()){
		// Error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}

	// Read input data. ESC or 'q' for quitting
	while( (char)keyboard != 'q' && (char)keyboard != 27 ){

		// Read the current frame
		if(!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			exit(EXIT_FAILURE);
		}

		// Get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
				cv::Scalar(255,255,255), -1);
		ss << capture.get(CV_CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
				FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

		// ------------- Get foreground masks ------------------------
		extractForeground( frame, learningRate );

		// IDEAS...
		// ---------------- Reduce noise -----------------------------
		applyMorphology( morphoOperation, morphoElement, morphoSize );

		// ----------------- Find contours ---------------------------
		vector<vector<Point> > contours;
		findContours( dst, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE );
		drawContours( frame, // draw contours here
				contours, // draw these contours
				-1, // draw all contours
				cv::Scalar(0,0,255), // set color
				2); // set thickness
		imshow("Contours", frame);

		// Get the input from the keyboard
		keyboard = (char)waitKey( 30 );
	}

	// Delete capture object
	capture.release();

	// Destroy GUI windows
	destroyAllWindows();

	return EXIT_SUCCESS;
}

// -----------------------------------------------------------------
//					REMOVE BACKGROUND / EXTRACT FOREGROUND
// Adapted from OpenCV Tutorials --> Video Analysis --> How to Use
// Background Subtraction Methods
// -----------------------------------------------------------------
void extractForeground( Mat frame, double learningRate )
{

	// Two different methods are used to generate two foreground masks:
	// MOG and MOG2, see OpenCV documentation

	// Update the background model
	//pMOG->operator()(frame, fgMaskMOG, learningRate);
	pMOG2->operator()(frame, fgMaskMOG2, learningRate);


	// Show the current frame and the foreground masks
	imshow("Frame", frame);
	//imshow("FG Mask MOG", fgMaskMOG);
	imshow("FG Mask MOG 2", fgMaskMOG2);

}

// -----------------------------------------------------------------
//					APPLY MORPHOLOGY OPERATIONS
// Apply the specified morphology operation
// 7 options: dilation, erosion, open, close, gradient, top hat,
// black hat
// -----------------------------------------------------------------
void applyMorphology( int morphoOperation, int morphoElement, int morphoSize )
{
	// Element type
	int morphoType;
	if( morphoElement == 0 ){ morphoType = MORPH_RECT; }
	else if( morphoElement == 1 ){ morphoType = MORPH_CROSS; }
	else if( morphoElement == 2) { morphoType = MORPH_ELLIPSE; }

	Mat element = getStructuringElement( morphoType, Size( 2*morphoSize + 1, 2*morphoSize+1 ), Point( morphoSize, morphoSize ) );

	// Apply the specified morphology operation
	// 0: Dilation, 1: Erosion
	// 2 - 6: Open, Close, Gradient, Top Hat or Black Hat
	// TODO: fgMask and dst should be arguments!!
	if (morphoOperation == 0)
	{
		dilate( fgMaskMOG2, dst, element );
	}
	else if (morphoOperation == 1)
	{
		erode( fgMaskMOG2, dst, element );
	}
	else if (morphoOperation >= 2 && morphoOperation < 7)
	{
		morphologyEx( fgMaskMOG2, dst, morphoOperation, element );
	}
	else
	{
		cerr << "Morphological operation not supported" << endl;
		exit(EXIT_FAILURE);
	}

	imshow( "Morphological operation result", dst );

}

void Dilation( int dilation_elem, int dilation_size )
{
	int dilation_type;
	if( dilation_elem == 0 ){ dilation_type = MORPH_RECT; }
	else if( dilation_elem == 1 ){ dilation_type = MORPH_CROSS; }
	else if( dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }

	Mat element = getStructuringElement( dilation_type,
			Size( 2*dilation_size + 1, 2*dilation_size+1 ),
			Point( dilation_size, dilation_size ) );
	/// Apply the dilation operation
	dilate( fgMaskMOG2, dst, element );
	imshow( "Dilation", dst );
}

void Erosion( int erosion_elem, int erosion_size )
{
	int erosion_type;
	if( erosion_elem == 0 ){ erosion_type = MORPH_RECT; }
	else if( erosion_elem == 1 ){ erosion_type = MORPH_CROSS; }
	else if( erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }

	Mat element = getStructuringElement( erosion_type,
			Size( 2*erosion_size + 1, 2*erosion_size+1 ),
			Point( erosion_size, erosion_size ) );

	// Apply the erosion operation
	erode( fgMaskMOG2, dst, element );
	imshow( "Erosion", dst );
}
